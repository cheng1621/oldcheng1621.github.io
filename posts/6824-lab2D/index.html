<!DOCTYPE html><html lang="en" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="6.824 lab2D" /><meta property="og:locale" content="en" /><meta name="description" content="Summary Log in Raft cannot grow without bound, since long Log occupies space and takes time to replay. Snapshotting is a simplest approach to compaction." /><meta property="og:description" content="Summary Log in Raft cannot grow without bound, since long Log occupies space and takes time to replay. Snapshotting is a simplest approach to compaction." /><link rel="canonical" href="https://cheng1621.github.io//posts/6824-lab2D/" /><meta property="og:url" content="https://cheng1621.github.io//posts/6824-lab2D/" /><meta property="og:site_name" content="HelloBen" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-22T19:10:10+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="6.824 lab2D" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"https://cheng1621.github.io//posts/6824-lab2D/"},"description":"Summary Log in Raft cannot grow without bound, since long Log occupies space and takes time to replay. Snapshotting is a simplest approach to compaction.","url":"https://cheng1621.github.io//posts/6824-lab2D/","@type":"BlogPosting","headline":"6.824 lab2D","dateModified":"2021-12-22T16:07:32+08:00","datePublished":"2021-04-22T19:10:10+08:00","@context":"https://schema.org"}</script><title>6.824 lab2D | HelloBen</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="HelloBen"><meta name="application-name" content="HelloBen"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/android-chrome-192x192.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">HelloBen</a></div><div class="site-subtitle font-italic">Keeping Trying</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/cheng1621" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['subencheng','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>6.824 lab2D</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>6.824 lab2D</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> BenchengSu </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Apr 22, 2021, 7:10 PM +0800" >Apr 22, 2021<i class="unloaded">2021-04-22T19:10:10+08:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 22, 2021, 3:07 AM -0500" >Dec 22, 2021<i class="unloaded">2021-12-22T16:07:32+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3968 words">22 min read</span></div></div><div class="post-content"><h1 id="summary">Summary</h1><p>Log in Raft cannot grow without bound, since long Log occupies space and takes time to replay. Snapshotting is a simplest approach to compaction.</p><h1 id="some-explanations">Some explanations.</h1><ol><li>every servers take snapshot independently.<li>an indexing scheme independent of log position is required, as snapshot would trim log sometimes. In my implementation, I add two parameters into <code class="language-plaintext highlighter-rouge">Raft</code> structure, named with <code class="language-plaintext highlighter-rouge">LastIncludedIndex</code> and <code class="language-plaintext highlighter-rouge">LastIncludedTerm</code>.<li>I combine <code class="language-plaintext highlighter-rouge">sendInstallsnapshot</code> with <code class="language-plaintext highlighter-rouge">heartbeat</code> function and <code class="language-plaintext highlighter-rouge">if rf.nextIndex[index] &lt; rf.LastIncludedIndex</code>, send snapshot.<li>Modifications to lines are needed where I use <code class="language-plaintext highlighter-rouge">len(rf.Log)</code> to represent the index of the Log.</ol><h1 id="result">Result.</h1><p><img data-proofer-ignore data-src="https://raw.githubusercontent.com/cheng1621/cheng1621.github.io/main/_posts/sample/6824_lab2D_result.png" alt="result" /></p><h1 id="code">Code.</h1><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
633
634
635
636
637
638
639
640
641
642
643
644
645
646
647
648
649
650
651
652
653
654
655
656
657
658
659
660
661
662
663
664
665
666
667
668
669
670
671
672
673
674
675
676
677
678
679
680
681
682
683
684
685
686
687
688
689
690
691
692
693
694
695
696
697
698
699
700
701
702
703
704
705
706
707
708
709
710
711
712
713
714
715
716
717
718
719
720
721
722
723
724
725
726
727
728
729
730
731
732
733
734
735
736
737
738
739
740
741
742
743
744
745
746
747
748
749
750
751
752
753
754
755
756
757
758
759
760
761
762
763
764
765
766
767
768
769
770
771
772
773
774
775
776
777
778
779
780
781
782
783
784
785
786
787
788
789
790
791
792
793
794
795
796
797
798
799
800
801
802
803
804
805
806
807
808
809
810
811
812
813
814
815
816
817
818
819
820
821
822
823
824
825
826
827
828
829
830
831
832
833
834
835
836
837
838
839
840
841
842
843
844
845
846
847
848
</pre><td class="rouge-code"><pre>package raft

//
// this is an outline of the API that raft must expose to
// the service (or tester). see comments below for
// each of these functions for more details.
//
// rf = Make(...)
//   create a new Raft server.
// rf.Start(command interface{}) (index, term, isleader)
//   start agreement on a new log entry
// rf.GetState() (term, isLeader)
//   ask a Raft for its current term, and whether it thinks it is leader
// ApplyMsg
//   each time a new entry is committed to the log, each Raft peer
//   should send an ApplyMsg to the service (or tester)
//   in the same server.
//

import (
	"bytes"
	"sync"
	"sync/atomic"

	"6.824/labgob"
	"6.824/labrpc"
)

// new import.
import "time"
import "math/rand"
// 3 states for servers.
const Candidate = 1
const Follower = 2
const Leader = 3
//
// as each Raft peer becomes aware that successive log entries are
// committed, the peer should send an ApplyMsg to the service (or
// tester) on the same server, via the applyCh passed to Make(). set
// CommandValid to true to indicate that the ApplyMsg contains a newly
// committed log entry.
//
// in part 2D you'll want to send other kinds of messages (e.g.,
// snapshots) on the applyCh, but set CommandValid to false for these
// other uses.
//
type ApplyMsg struct {
	CommandValid bool
	Command      interface{}
	CommandIndex int

	// For 2D:
	SnapshotValid bool
	Snapshot      []byte
	SnapshotTerm  int
	SnapshotIndex int
}

//
// A Go object implementing a single Raft peer.
//
type Raft struct {
	mu        sync.Mutex          // Lock to protect shared access to this peer's state
	peers     []*labrpc.ClientEnd // RPC end points of all peers
	persister *Persister          // Object to hold this peer's persisted state
	me        int                 // this peer's index into peers[]
	dead      int32               // set by Kill()

	// Your data here (2A, 2B, 2C).
	// Look at the paper's Figure 2 for a description of what
	// state a Raft server must maintain.
	// (new).
	state int
	Time time.Time
	VoteCount int
	Timeout int
	// (new) end

	CurrentTerm int
	VoteFor int
	Log []LogEntry

	commitIndex int
	lastApplied int
	
	nextIndex []int
	matchIndex []int

	applyCh chan ApplyMsg

	LastIncludedIndex int
	LastIncludedTerm int
}

// return currentTerm and whether this server
// believes it is the leader.
func (rf *Raft) GetState() (int, bool) {

	var term int
	var isleader bool
	// Your code here (2A).
	rf.mu.Lock()
	defer rf.mu.Unlock()
	term = rf.CurrentTerm
	if rf.state == Leader {
		isleader = true
	}
	return term, isleader
}

//
// save Raft's persistent state to stable storage,
// where it can later be retrieved after a crash and restart.
// see paper's Figure 2 for a description of what should be persistent.
//
func (rf *Raft) persist() {
	// Your code here (2C).
	// Example:
	w := new(bytes.Buffer)
	e := labgob.NewEncoder(w)
	e.Encode(rf.CurrentTerm)
	e.Encode(rf.VoteFor)
	e.Encode(rf.Log)
	data := w.Bytes()
	rf.persister.SaveRaftState(data)
}


//
// restore previously persisted state.
//
func (rf *Raft) readPersist(data []byte) {
	if data == nil || len(data) &lt; 1 { // bootstrap without any state?
		return
	}
	// Your code here (2C).
	// Example:
	r := bytes.NewBuffer(data)
	d := labgob.NewDecoder(r)
	var term int
	var votefor int
	var log []LogEntry
	if d.Decode(&amp;term) != nil ||
	   d.Decode(&amp;votefor) != nil ||
	   d.Decode(&amp;log) != nil {
	  return
	} else {
	  rf.CurrentTerm = term
	  rf.VoteFor = votefor
	  rf.Log = log
	}
}
// snapshot argument.
type SnapshotArgs struct {
	Term int
	LeaderId int
	LastIncludedIndex int
	LastIncludedTerm int
	Data []byte
	Done bool
	// todo. Offset.
}

// snapshot result
type SnapshotReply struct {
	Term int
	LastIncludedIndex int
}



// the service says it has created a snapshot that has
// all info up to and including index. this means the
// service no longer needs the log through (and including)
// that index. Raft should now trim its log as much as possible.
func (rf *Raft) Snapshot(index int, snapshot []byte) {
	// Your code here (2D).
	rf.mu.Lock()
	defer rf.mu.Unlock()
	i := 0
	n := len(rf.Log)
	for ;i &lt; n;i++ {
		if rf.LastIncludedIndex + i &gt;= index {
			break
		}
		rf.LastIncludedTerm = rf.Log[i].Term
	}
	// update lastincludedindex.
	rf.LastIncludedIndex = rf.LastIncludedIndex + i;
	if i == n {
		// trim the entire log.
		rf.Log = rf.Log[:0]
		rf.lastApplied = max(rf.LastIncludedIndex,rf.lastApplied)
		rf.commitIndex = max(rf.LastIncludedIndex,rf.commitIndex)
	} else {
		rf.Log = rf.Log[i:]
		rf.lastApplied = max(rf.LastIncludedIndex,rf.lastApplied)
		rf.commitIndex = max(rf.LastIncludedIndex,rf.commitIndex)
	}
	
	// update the data.
	rf.persist()
	rf.persister.SaveStateAndSnapshot(rf.persister.ReadRaftState(),snapshot)
	return
}

// send InstallSnapshot RPC.
func (rf *Raft) sendInstallSnapshot(server int,args *SnapshotArgs, reply *SnapshotReply) bool {
	ok := rf.peers[server].Call("Raft.InstallSnapshotHandler", args, reply)
	return ok
}
// InstallSnapshot handler.
func (rf *Raft) InstallSnapshotHandler(args *SnapshotArgs, reply *SnapshotReply) {
	rf.mu.Lock()
	reply.Term = rf.CurrentTerm
	DPrintf("me:%d, lastIncludedIndex: %d",rf.me,rf.LastIncludedIndex)
	reply.LastIncludedIndex = rf.LastIncludedIndex
	if rf.CurrentTerm &gt; args.Term {
		rf.mu.Unlock()
		return
	}
	snapshot := clone(args.Data)
	msg := ApplyMsg {
		CommandValid : false,
		// For 2D:
		SnapshotValid : true,
		Snapshot : snapshot,
		SnapshotTerm : args.LastIncludedTerm,
		SnapshotIndex : args.LastIncludedIndex,
	}
	rf.mu.Unlock()
	rf.applyCh &lt;- msg
}


//
// A service wants to switch to snapshot.  Only do so if Raft hasn't
// have more recent info since it communicate the snapshot on applyCh.
//
func (rf *Raft) CondInstallSnapshot(lastIncludedTerm int, lastIncludedIndex int, snapshot []byte) bool {
	// Your code here (2D).
	rf.mu.Lock()
	defer rf.mu.Unlock()
	if lastIncludedTerm &lt; rf.LastIncludedTerm || lastIncludedIndex &lt; rf.LastIncludedIndex{
		return false
	}
	i := 0
	n := len(rf.Log)
	for ;i &lt; n;i++ {
		if rf.LastIncludedIndex + i &gt;= lastIncludedIndex {
			break
		}
		rf.LastIncludedTerm = lastIncludedTerm
	}
	rf.LastIncludedIndex = lastIncludedIndex
	if i == n {
		// trim the entire log.
		rf.Log = rf.Log[:0]
		rf.lastApplied = max(rf.LastIncludedIndex,rf.lastApplied)
		rf.commitIndex = max(rf.LastIncludedIndex,rf.commitIndex)
	} else {
		rf.Log = rf.Log[i:]
		rf.lastApplied = max(rf.LastIncludedIndex,rf.lastApplied)
		rf.commitIndex = max(rf.LastIncludedIndex,rf.commitIndex)
	}
	rf.persist()
	rf.persister.SaveStateAndSnapshot(rf.persister.ReadRaftState(),snapshot)
	return true
}
// (2A) structure log entries.
type LogEntry struct {
	Term int 
	Command interface{}  // still don't know about the command.
}

// (2A) AppendEntries structure.
type AppendEntriesArgs struct {
	Term int
	Leaderindex int
	PrevLogIndex int
	PrevLogTerm int
	Entries []LogEntry
	LeaderCommit int
}
type AppendEntriesReply struct {
	Term int
	Success bool
	// (2C) new parameter.
	Xterm int
	Xindex int
}

// (2A) AppendEntries Handler.
func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply){
	rf.mu.Lock()
	defer rf.mu.Unlock()
	DPrintf("me:%d,term: %d,lastApplied:%d,commitIndex:%d,lastIncludedIndex:%d.",rf.me,rf.CurrentTerm,rf.lastApplied,rf.commitIndex,rf.LastIncludedIndex)
	DPrintf("me:%d, %v",rf.me,rf.Log)
	if args.Term &lt; rf.CurrentTerm {
		reply.Term = rf.CurrentTerm
		reply.Success = false
		return
	}
	// (2B.)
	// (2B).Figure 2: AppendEntries RPC, implementation 2. something
	if args.Term &gt; rf.CurrentTerm {
		rf.CurrentTerm = args.Term
		rf.persist()
		rf.convertToFollower()
	}
	if len(rf.Log) + rf.LastIncludedIndex &lt; args.PrevLogIndex {
		reply.Term = rf.CurrentTerm
		reply.Success = false
		reply.Xindex = len(rf.Log) + rf.LastIncludedIndex
		reply.Xterm = -1
		rf.Time = time.Now()
		return
	}
	if args.PrevLogIndex &gt; rf.LastIncludedIndex &amp;&amp; args.PrevLogIndex &lt; len(rf.Log) + 1 + rf.LastIncludedIndex &amp;&amp; rf.Log[args.PrevLogIndex - 1 - rf.LastIncludedIndex].Term != args.PrevLogTerm {
		reply.Term = rf.CurrentTerm
		reply.Success = false
		reply.Xterm = rf.Log[args.PrevLogIndex - rf.LastIncludedIndex - 1].Term
		for i := 0;i &lt; len(rf.Log);i++{
			if rf.Log[i].Term == reply.Xterm {
				reply.Xindex = i + 1 + rf.LastIncludedIndex
				break
			}
		}
		rf.Time = time.Now()
		return
	}
	// implementation 3 &amp; implementation 4. delete existing entry if conflict happens
	index := -1
	for i := 0;i &lt; len(args.Entries);i++{
		if len(rf.Log) + rf.LastIncludedIndex &lt; (args.PrevLogIndex + 2 + i) || rf.Log[args.PrevLogIndex + 1 + i - rf.LastIncludedIndex].Term != args.Entries[i].Term{
			index = i
			break
		}
	}
	if index != -1 {
		rf.Log = rf.Log[:index + args.PrevLogIndex - rf.LastIncludedIndex]
		for i := index;i &lt; len(args.Entries);i++{
			rf.Log = append(rf.Log,args.Entries[i])
		}
		rf.persist()
	} 
	
	// implementation 5.
	if args.LeaderCommit &gt; rf.commitIndex {
		rf.Commit(min(args.LeaderCommit,len(rf.Log) + rf.LastIncludedIndex))
	}
	reply.Term = rf.CurrentTerm
	reply.Success = true
	rf.Time = time.Now()
}

func (rf *Raft) sendAppendEntries(server int,args *AppendEntriesArgs, reply *AppendEntriesReply) bool {
	ok := rf.peers[server].Call("Raft.AppendEntries", args, reply)
	return ok
}
//
// example RequestVote RPC arguments structure.
// field names must start with capital letters!
//
type RequestVoteArgs struct {
	// Your data here (2A, 2B).
	Term int
	Candidateindex int 
	LastLogIndex int
	LastLogTerm int
}

//
// example RequestVote RPC reply structure.
// field names must start with capital letters!
//
type RequestVoteReply struct {
	// Your data here (2A).
	Term int
	VoteGranted bool
}

//
// example RequestVote RPC handler.
//
func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) {
	// Your code here (2A, 2B).
	rf.mu.Lock()
	defer rf.mu.Unlock()
	
	if args.Term &lt; rf.CurrentTerm {
		reply.Term = rf.CurrentTerm
		reply.VoteGranted = false;
		return
	}
	if args.Term &gt; rf.CurrentTerm {
		rf.CurrentTerm = args.Term
		rf.persist()
		rf.convertToFollower()
	}
	if rf.VoteFor == -1 || rf.VoteFor == args.Candidateindex {
		// (2B. leader election.)
		if len(rf.Log) &gt; 0 {
			if args.LastLogTerm &gt; rf.Log[len(rf.Log) - 1].Term {
				rf.VoteFor = args.Candidateindex
				reply.VoteGranted = true
				reply.Term = rf.CurrentTerm
				rf.Time = time.Now()
				rf.persist()
				return
			}
			if (args.LastLogTerm == rf.Log[len(rf.Log) - 1].Term &amp;&amp; args.LastLogIndex &gt;= len(rf.Log) + rf.LastIncludedIndex){
				rf.VoteFor = args.Candidateindex
				reply.VoteGranted = true
				reply.Term = rf.CurrentTerm
				rf.Time = time.Now()
				rf.persist()
				return
			}
		} else {
			if args.LastLogTerm &gt; rf.LastIncludedTerm || (args.LastLogTerm == rf.LastIncludedTerm &amp;&amp; args.LastLogIndex &gt;= rf.LastIncludedIndex){
				rf.VoteFor = args.Candidateindex
				reply.VoteGranted = true
				reply.Term = rf.CurrentTerm
				rf.Time = time.Now()
				rf.persist()
				return
			}
		}
	}
	reply.VoteGranted = false
	reply.Term = rf.CurrentTerm
}

//
// example code to send a RequestVote RPC to a server.
// server is the index of the target server in rf.peers[].
// expects RPC arguments in args.
// fills in *reply with RPC reply, so caller should
// pass &amp;reply.
// the types of the args and reply passed to Call() must be
// the same as the types of the arguments declared in the
// handler function (including whether they are pointers).
//
// The labrpc package simulates a lossy network, in which servers
// may be unreachable, and in which requests and replies may be lost.
// Call() sends a request and waits for a reply. If a reply arrives
// within a timeout interval, Call() returns true; otherwise
// Call() returns false. Thus Call() may not return for a while.
// A false return can be caused by a dead server, a live server that
// can't be reached, a lost request, or a lost reply.
//
// Call() is guaranteed to return (perhaps after a delay) *except* if the
// handler function on the server side does not return.  Thus there
// is no need to implement your own timeouts around Call().
//
// look at the comments in ../labrpc/labrpc.go for more details.
//
// if you're having trouble getting RPC to work, check that you've
// capitalized all field names in structs passed over RPC, and
// that the caller passes the address of the reply struct with &amp;, not
// the struct itself.
//
func (rf *Raft) sendRequestVote(server int, args *RequestVoteArgs, reply *RequestVoteReply) bool {
	ok := rf.peers[server].Call("Raft.RequestVote", args, reply)
	return ok
}


//
// the service using Raft (e.g. a k/v server) wants to start
// agreement on the next command to be appended to Raft's log. if this
// server isn't the leader, returns false. otherwise start the
// agreement and return immediately. there is no guarantee that this
// command will ever be committed to the Raft log, since the leader
// may fail or lose an election. even if the Raft instance has been killed,
// this function should return gracefully.
//
// the first return value is the index that the command will appear at
// if it's ever committed. the second return value is the current
// term. the third return value is true if this server believes it is
// the leader.
//
func (rf *Raft) Start(command interface{}) (int, int, bool) {
	index := -1
	term := -1
	isLeader := true

	// Your code here (2B).
	rf.mu.Lock()
	defer rf.mu.Unlock()
	if rf.state != Leader {
		isLeader = false
		return index, term, isLeader
	}
	// append command to rf.Log.
	new_log := LogEntry{}
	new_log.Term = rf.CurrentTerm
	new_log.Command = command
	rf.Log = append(rf.Log,new_log) // append new command to local log.
	rf.persist()
	index = len(rf.Log) + rf.LastIncludedIndex
	term = rf.CurrentTerm
	rf.matchIndex[rf.me] = index
	rf.nextIndex[rf.me] = index + 1
	

	return index, term, isLeader
}

//
// the tester doesn't halt goroutines created by Raft after each test,
// but it does call the Kill() method. your code can use killed() to
// check whether Kill() has been called. the use of atomic avoids the
// need for a lock.
//
// the issue is that long-running goroutines use memory and may chew
// up CPU time, perhaps causing later tests to fail and generating
// confusing debug output. any goroutine with a long-running loop
// should call killed() to check whether it should stop.
//
func (rf *Raft) Kill() {
	atomic.StoreInt32(&amp;rf.dead, 1)
	// Your code here, if desired.
}

func (rf *Raft) killed() bool {
	z := atomic.LoadInt32(&amp;rf.dead)
	return z == 1
}

// The ticker go routine starts a new election if this peer hasn't received
// heartsbeats recently.
func (rf *Raft) ticker() {
	for rf.killed() == false {

		// Your code here to check if a leader election should
		// be started and to randomize sleeping time using
		// time.Sleep().
		rf.mu.Lock()
		go rf.SendCommitEntry()
		switch rf.state {
		case Follower:
			if int(time.Since(rf.Time) /time.Millisecond) &gt; rf.Timeout{
				rf.converttoCandidate()
			}
			rf.mu.Unlock()
		case Candidate:
			if int(time.Since(rf.Time) /time.Millisecond) &gt; rf.Timeout {
				go rf.getVote()
			}
			rf.mu.Unlock()
		case Leader:
			rf.heartbeat()
			rf.mu.Unlock()
		}
		time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
	}
}
func (rf *Raft) convertToLeader() {
	
	// (2B.)
	// initialization. (nextIndex and matchIndex.)
	rf.nextIndex = make([]int,len(rf.peers))
	rf.matchIndex = make([]int,len(rf.peers))
	for i:= 0;i &lt; len(rf.peers);i++{
		rf.nextIndex[i] = len(rf.Log) + rf.LastIncludedIndex + 1
		rf.matchIndex[i] = 0
	}
	rf.state = Leader
	go rf.heartbeat()
}
func (rf *Raft) converttoCandidate(){
	rf.CurrentTerm++
	rf.VoteFor = rf.me
	rf.state = Candidate
	rf.VoteCount = 1;
	rf.persist()
	go rf.getVote()
}
// send to other server except the Candidate server.
func (rf *Raft) getVote(){
	rf.mu.Lock()
	rf.CurrentTerm++
	rf.Timeout = rand.Intn(200) + 400
	rf.Time = time.Now()
	rf.VoteCount = 1
	rf.persist()
	rf.mu.Unlock()
	// (2B. log replication)
	
	for i := 0;i &lt; len(rf.peers);i++{
		if i != rf.me {
			go func(index int){
				rf.mu.Lock()
				args := RequestVoteArgs{
					Term: rf.CurrentTerm,
					Candidateindex : rf.me,
					LastLogIndex: len(rf.Log) + rf.LastIncludedIndex,
					LastLogTerm: rf.LastIncludedTerm,
				}
				if len(rf.Log) &gt; 0 {
					args.LastLogTerm = rf.Log[len(rf.Log) - 1].Term
				}
				rf.mu.Unlock()
				reply := RequestVoteReply{}
				ok := rf.sendRequestVote(index,&amp;args,&amp;reply)
				if !ok {
					return
				}
				rf.mu.Lock()
				defer rf.mu.Unlock()
				if rf.state != Candidate {
					return
				}
				if reply.VoteGranted {
					rf.VoteCount++
				} 
				if rf.VoteCount &gt; len(rf.peers) / 2{
					rf.convertToLeader()
					return
				}
			}(i)
		}
	}
}
func (rf *Raft) convertToFollower(){
	rf.state = Follower
	rf.VoteFor = -1
	rf.persist()
}
// heartbeat. empty AppendEntries to keep authority.
func (rf *Raft) heartbeat(){
	for i := 0;i &lt; len(rf.peers);i++{
		if i != rf.me{
			go func(index int) {
				rf.mu.Lock()
				if rf.state != Leader {
					rf.mu.Unlock()
					return
				}
				DPrintf("me:%d,%v",rf.me,rf.Log)
				DPrintf("nextIndex[%d] : %d",index,rf.nextIndex[index])
				// send snapshot if log lag behind.
				if rf.LastIncludedIndex &gt; 0 &amp;&amp; rf.nextIndex[index] &lt;= rf.LastIncludedIndex {
					args := SnapshotArgs {
						Term : rf.CurrentTerm,
						LeaderId : rf.me,
						LastIncludedIndex : rf.LastIncludedIndex,
						LastIncludedTerm : rf.LastIncludedTerm,
						Data : rf.persister.ReadSnapshot(),
					}
					reply := SnapshotReply{}
					rf.mu.Unlock()
					ok := rf.sendInstallSnapshot(index,&amp;args,&amp;reply)
					if ok {
						rf.mu.Lock()
						if reply.Term &gt; rf.CurrentTerm {
							rf.CurrentTerm = reply.Term
							rf.convertToFollower()
						} else {
							rf.nextIndex[index] = reply.LastIncludedIndex + 1
							rf.matchIndex[index] = reply.LastIncludedIndex
						}
						rf.mu.Unlock()
					}
					
					return
				}
				prevLogIndex := rf.nextIndex[index] - 1
				entries := make([]LogEntry, len(rf.Log[rf.nextIndex[index] - 1 - rf.LastIncludedIndex:]))
				copy(entries, rf.Log[(prevLogIndex - rf.LastIncludedIndex):])
				args := AppendEntriesArgs{
					Term : rf.CurrentTerm,
					Leaderindex : rf.me,
					PrevLogIndex :prevLogIndex,
					PrevLogTerm : rf.LastIncludedTerm,
					// Entries : rf.Log[PrevLogIndex + 1:],
					Entries: entries,
					LeaderCommit : rf.commitIndex,
				}
				if prevLogIndex &gt; rf.LastIncludedIndex {
					args.PrevLogTerm = rf.Log[prevLogIndex - 1 - rf.LastIncludedIndex].Term
				}
				if rf.state != Leader {
					rf.mu.Unlock()
					return
				}
				rf.mu.Unlock()
				reply := AppendEntriesReply{}
				ok := rf.sendAppendEntries(index,&amp;args,&amp;reply)
				if !ok {
					return
				}
				rf.mu.Lock()
				defer rf.mu.Unlock()
				if reply.Success {
					rf.matchIndex[index] = args.PrevLogIndex + len(args.Entries)
            		rf.nextIndex[index] = rf.matchIndex[index] + 1
					// check if replicated on majority of servers.
					for N := len(rf.Log) + rf.LastIncludedIndex; N &gt; rf.commitIndex;N--{
						num := 0
						for j:= 0;j &lt; len(rf.peers);j++{
							if rf.matchIndex[j] &gt;= N{
								num++;
							}
							if num &gt; len(rf.peers) / 2 {
								rf.Commit(N)
								break
							}
						}
					}
				} else {
					if reply.Term &gt; rf.CurrentTerm {
						rf.CurrentTerm = reply.Term
						rf.persist()
						rf.convertToFollower()
					} else {
						// (2C.)
						if reply.Xindex &gt; 0 {
							firstConflict := reply.Xindex
							if reply.Xterm != -1 { // not missing logs
								for i := 0; i &lt; len(rf.Log); i++ {
									if rf.Log[i].Term != reply.Xterm {
										continue
									}
									for i &lt; len(rf.Log) + 1 &amp;&amp; rf.Log[i].Term == reply.Xterm {
										i++ // the last conflict log's next index
									}
									firstConflict = i
									break
								}
							}
							rf.nextIndex[index] = firstConflict // next sync, send conflicted logs to the follower
						} else {
							rf.nextIndex[index] = 1
						}
						// if reply.Term &gt; rf.CurrentTerm {
						// 	rf.CurrentTerm = reply.Term
						// 	rf.convertToFollower()
						// } else {
						// 	if rf.nextIndex[index] &gt; 1 {
						// 		rf.nextIndex[index] = args.PrevLogIndex
						// 	}
						// }
					}
				}
			}(i)
		}
	}
}
func (rf *Raft) Commit(N int){
	rf.commitIndex = N
}
func (rf *Raft) SendCommitEntry(){
	rf.mu.Lock()
	start := rf.lastApplied
	end := rf.commitIndex
	if (start &gt;= end){
		rf.mu.Unlock()
		return
	}
	rf.mu.Unlock()
	for i := start;i &lt; end;i++{
		rf.mu.Lock()
		if start != rf.lastApplied || end != rf.commitIndex {
			rf.mu.Unlock()
			return
		}
		msg := ApplyMsg{
			CommandValid: true,
			CommandIndex : i + 1,
			SnapshotValid : false,
		}
		msg.Command = rf.Log[i - rf.LastIncludedIndex].Command
		rf.mu.Unlock()
		rf.applyCh &lt;- msg
	}
	rf.mu.Lock()
	rf.lastApplied = end
	rf.mu.Unlock()
}
func (rf *Raft) LeaderElection(){
	for {
		rf.mu.Lock()
		switch rf.state {
		case Follower:
			if int(time.Since(rf.Time) /time.Millisecond) &gt; rf.Timeout{
				rf.converttoCandidate()
			}
			rf.mu.Unlock()
		case Candidate:
			if int(time.Since(rf.Time) /time.Millisecond) &gt; rf.Timeout {
				go rf.getVote()
			}
			rf.mu.Unlock()
		case Leader:
			rf.heartbeat()
			rf.mu.Unlock()
		}
		time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
	}
}
//
// the service or tester wants to create a Raft server. the ports
// of all the Raft servers (including this one) are in peers[]. this
// server's port is peers[me]. all the servers' peers[] arrays
// have the same order. persister is a place for this server to
// save its persistent state, and also initially holds the most
// recent saved state, if any. applyCh is a channel on which the
// tester or service expects Raft to send ApplyMsg messages.
// Make() must return quickly, so it should start goroutines
// for any long-running work.
//
func Make(peers []*labrpc.ClientEnd, me int,
	persister *Persister, applyCh chan ApplyMsg) *Raft {
	rf := &amp;Raft{}
	rf.peers = peers
	rf.persister = persister
	rf.me = me

	// Your initialization code here (2A, 2B, 2C).

	// (2A). Start.
	// rand.Seed(time.Now().Unix()) // 
	rf.state = Follower
	rf.CurrentTerm = 0
	rf.VoteFor = -1
	rf.Time = time.Now()
	rf.Timeout = rand.Intn(200) + 400
	rf.applyCh = applyCh
	

	rf.LastIncludedIndex = 0
	rf.LastIncludedTerm = -1
	// initialize from state persisted before a crash
	rf.readPersist(persister.ReadRaftState())
	// if len(rf.Log) == 0{
	// 	first_log := LogEntry{Term : -1}
	// 	rf.Log = append(rf.Log,first_log)
	// }
	// start ticker goroutine to start elections
	go rf.ticker()


	return rf
}

</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/distributed-system/'>Distributed System</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/distributed-system/" class="post-tag no-text-decoration" >Distributed System</a> <a href="/tags/raft/" class="post-tag no-text-decoration" >Raft</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=6.824 lab2D - HelloBen&url=https://cheng1621.github.io//posts/6824-lab2D/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=6.824 lab2D - HelloBen&u=https://cheng1621.github.io//posts/6824-lab2D/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=6.824 lab2D - HelloBen&url=https://cheng1621.github.io//posts/6824-lab2D/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/amazon_leadership/">Amazon bq question</a><li><a href="/posts/OOD_Design/">Design Parking Lot</a><li><a href="/posts/fault-tolerant-system/">6.824 (假设能拿到offer的项目）</a><li><a href="/posts/lowLatency_MultiDatacenter_Databases_Using_Replicated_Commit/">Low-Latency Multi-Datacenter Databases using Replicated Commit Note</a><li><a href="/posts/Frangipani/">frangipani</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/distributed-system/">Distributed System</a> <a class="post-tag" href="/tags/raft/">Raft</a> <a class="post-tag" href="/tags/large-scale-software-engineering/">Large Scale Software Engineering</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/amazon/">Amazon</a> <a class="post-tag" href="/tags/aurora/">Aurora</a> <a class="post-tag" href="/tags/craq/">CRAQ</a> <a class="post-tag" href="/tags/frangipani/">frangipani</a> <a class="post-tag" href="/tags/gfs/">gfs</a> <a class="post-tag" href="/tags/kvservice/">kvservice</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/fault-tolerant-system/"><div class="card-body"> <span class="timeago small" >Jun 1, 2021<i class="unloaded">2021-06-01T19:10:10+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>6.824 (假设能拿到offer的项目）</h3><div class="text-muted small"><p> 1.先来个自我介绍吧。 嗯嗯，我之前写过一个基于LLVM的小型编译器，写过一个小型操作系统的kernel，最近写过一个有关分布式系统的，这个分布式系统实际上就是一个可容错性的分布式key/value数据库，支持动态扩容，负载均衡，线性一致性，这个一致性是基于raft共识算法，嗯，raft 就是为了在不同的服务器保持一致性的一种算法。这个数据库支持一定的容错，就是一个服务器崩了，另一个服务器马...</p></div></div></a></div><div class="card"> <a href="/posts/6824-lab2A/"><div class="card-body"> <span class="timeago small" >Dec 5, 2020<i class="unloaded">2020-12-05T10:59:10+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>6.824 Lab2A</h3><div class="text-muted small"><p> Preparation. Raft paper Summary. There is only one leader in Raft algorithm. Leader remains authority through sending AppendEntries to peers. if one peer doesn’t hear from the leader or Candid...</p></div></div></a></div><div class="card"> <a href="/posts/6824-lab2B/"><div class="card-body"> <span class="timeago small" >Dec 26, 2020<i class="unloaded">2020-12-26T01:21:10+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>6.824 Lab2B</h3><div class="text-muted small"><p> Preparation. Raft paper Raft Explanation Some details about Raft Explanation.(the link above) Actually, I know the big picture of the Raft consenus algorithm from the link above. Then I impl...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/llvm-compiler/" class="btn btn-outline-primary" prompt="Older"><p>LL(1)</p></a> <a href="/posts/fault-system-system-v2/" class="btn btn-outline-primary" prompt="Newer"><p>6.824</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">BenchengSu</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/distributed-system/">Distributed System</a> <a class="post-tag" href="/tags/raft/">Raft</a> <a class="post-tag" href="/tags/large-scale-software-engineering/">Large Scale Software Engineering</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/amazon/">Amazon</a> <a class="post-tag" href="/tags/aurora/">Aurora</a> <a class="post-tag" href="/tags/craq/">CRAQ</a> <a class="post-tag" href="/tags/frangipani/">frangipani</a> <a class="post-tag" href="/tags/gfs/">gfs</a> <a class="post-tag" href="/tags/kvservice/">kvservice</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
